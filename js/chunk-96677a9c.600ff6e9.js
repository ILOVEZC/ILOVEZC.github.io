(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-96677a9c"],{6426:function(e,t,n){function r(){var e=function(){var e=this,t=e.$createElement;e._self._c;return e._m(0)},t=[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"frontmatter-markdown"},[r("h1",[e._v("Vue 中的响应性是如何工作的")]),e._v(" "),r("p",[e._v("我们无法直接追踪对上述示例中局部变量的读写，原生 JavaScript 没有提供任何机制能做到这一点。"),r("strong",[e._v("但是")]),e._v("，我们是可以追踪"),r("strong",[e._v("对象属性")]),e._v("的读写的。")]),e._v(" "),r("blockquote",[r("p",[e._v("在 JavaScript 中有两种劫持 property 访问的方式："),r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get",target:"_blank"}},[e._v("getter")]),e._v(" / "),r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set",target:"_blank"}},[e._v("setters")]),e._v(" 和 "),r("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",target:"_blank"}},[e._v("Proxies")]),e._v("。Vue 2 使用 getter / setters 完全是出于支持旧版本浏览器的限制。而在 Vue 3 中则使用了 Proxy 来创建响应式对象，仅将 getter / setter 用于 ref。")])]),e._v(" "),r("h2",[e._v("了解 Render 函数")]),e._v(" "),r("ul",[r("li",[e._v("Render 函数与我们的 template 标签作用一样,template 是 Render 的进一步封装,并且 Render 里面可以填入自定义组件")]),e._v(" "),r("li",[e._v("本质上，template 先预编译成虚拟 dom 渲染函数")])]),e._v(" "),r("pre",[r("code",{pre:!0,attrs:{class:"hljs language-vue"}},[e._v("<script>\nexport default {\n  props: {\n    tag: String,\n  },\n  data() {\n    return {\n      people: ['哈默', '小夏', '小野'],\n    }\n  },\n  render(createElement) {\n    return createElement(\n      this.tag,\n      {},\n      this.people.map((name) =>\n        createElement(\n          'li',\n          {\n            attrs: { class: 'test' },\n            on: {\n              click: () => {\n                console.log('li clicked!')\n              },\n            },\n          },\n          `${name}`\n        )\n      )\n    )\n  },\n}\n<\/script>\n")])]),e._v(" "),r("h2",[e._v("render 函数怎么用")]),e._v(" "),r("p",[e._v("常用场景:")]),e._v(" "),r("ul",[r("li",[e._v("动态标签(函数时声明的方式，根据不同的需求采用不同的标签)，对组件进行更细致的动态编辑")])]),e._v(" "),r("pre",[r("code",{pre:!0,attrs:{class:"hljs language-vue"}},[e._v("<script lang=\"ts\">\nimport { h } from 'vue'\nexport default {\n  props: {\n    id: Number,\n  },\n  render() {\n    return h(`h${this.id}`, 'hello world')\n  },\n}\n<\/script>\n")])]),e._v(" "),r("h2",[e._v("什么是虚拟 dom")]),e._v(" "),r("ul",[r("li",[e._v("通用性框架本质工作是将数据和页面渲染进行一一对应，而主流开发数据和渲染存在多对多关系（即一个数据可以用在多处，一处可以用多个数据），但是数据修改时进行一一对应是一件很难的事情。")]),e._v(" "),r("li",[e._v("如果需要对界面全部重新生成，会消耗很多性能，所以改为全面生成虚拟 dom，通过新旧虚拟 dom 对比，来修改真实 dom")]),e._v(" "),r("li",[e._v("虚拟 dom 本质上是对象，抽象出来进一步作为 UI 界面，有利于把框架推广到桌面端，移动端等。")])]),e._v(" "),r("h2",[e._v("虚拟 dom 的对比方式 diff")]),e._v(" "),r("h3",[e._v("以 v-key 为例谈谈影响")]),e._v(" "),r("p",[e._v("如果没有 v-key,意味着 v-for 循环内的子元素无明显区别，都视作相同的 dom，那么循环内 dom 里面的内容都要被修改。加入 v-key 后就意味着 dom 之间有区别，会对 dom 的重新排序，而不是对真实 dom 进行修改。")]),e._v(" "),r("p",[e._v("这种情况不仅仅出现在 for 循环内，如果两个需要 v-if 互相切换的 dom 之间没有区别，也会被视作一直占用同一个节点，v-if 切换后没有新生成 dom，而是重新给 dom 的一些属性复制然后复用")]),e._v(" "),r("h3",[e._v("diff 如何工作")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("本质就是比较两个 JS 对象的差异")])]),e._v(" "),r("li",[r("p",[e._v("diff 的时机:当组件创建时，以及依赖的属性或数据变化时，会运行一个函数，该函数首先运行__render 生成一棵新的虚拟 dom 树(vnode tree)，然后运行__update，传入虚拟树的根节点，将两棵虚拟树进行对比，最终完成对真实 dom 的更新")])])]),e._v(" "),r("p",[r("img",{attrs:{src:n("f6fa"),alt:"image-20240202154947147"}})]),e._v(" "),r("ul",[r("li",[e._v("diff 的比对方法是双指针法")])]),e._v(" "),r("h2",[e._v("Vue2 的响应式原理")]),e._v(" "),r("p",[e._v("通过 "),r("strong",[e._v("object.defineProperty")]),e._v(" 遍历每一个属性并为其添加上 "),r("strong",[e._v("getter")]),e._v(" 和 "),r("strong",[e._v("setter")]),e._v(" 方法用来监听数据的读取与改变，然后结合 "),r("strong",[e._v("观察者模式")]),e._v("，通知页面视图发生改变，从而实现数据的响应式原理。")]),e._v(" "),r("p",[e._v("Vue 是非侵入性的响应式系统，遍历对象并使用"),r("strong",[e._v("Object.defineProperty")]),e._v("对对象的属性进行数据劫持，当数据发生变化时，触发数据劫持的"),r("strong",[e._v("setter")]),e._v("函数，通知组件实例的"),r("strong",[e._v("watcher")]),e._v("需要进行视图更新，以此来实现响应式。")]),e._v(" "),r("h2",[e._v("Vue3 的响应式原理")]),e._v(" "),r("h4",[e._v("什么是响应式")]),e._v(" "),r("p",[e._v("当数据改变时，引用数据的函数会自动重新执行。")]),e._v(" "),r("h4",[e._v("什么是副作用函数")]),e._v(" "),r("p",[e._v("如果一个函数引用了外部的资源，这个函数会受到外部资源改变的影响，那么我们就说这个函数存在副作用。")]),e._v(" "),r("h4",[e._v("自定义设置响应过程")]),e._v(" "),r("p",[e._v("Proxy 感知数据改变，拦截赋值操作，再赋值后把副作用函数执行一次")])])}];return{render:e,staticRenderFns:t}}const v=r();e.exports={attributes:{},vue:{component:{data:function(){return{templateRender:null}},render:function(e){return this.templateRender?this.templateRender():e("div","Rendering")},created:function(){this.templateRender=v.render,this.$options.staticRenderFns=v.staticRenderFns}}}}},f6fa:function(e,t,n){e.exports=n.p+"img/image-20240202154947147.6c38103f.png"}}]);
//# sourceMappingURL=chunk-96677a9c.600ff6e9.js.map